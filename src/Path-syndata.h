// --------------------------------------------------------------------------------
// Synthetic Data
//
// In terms of transfer tools, Synthetic Data is defined as data that is generated
// 'in memory' by a transfer tool or utility, and written out to a file or files.
// This data can be patterned, or random in nature. The defining feature of this 
// data is that it comes from the transfer program itself, and not from a 
// conventional source, such as a file on disk.
//
// Synthetic data is used primarily for testing and development. For example,
// in the case of performance testing, if the tester wishes to eliminate the 
// time it takes to read data from disk or the file system, then specifying a
// synthetic data source would do that, since the data is generated from memory.
// Likewise, if sample files or trees are needed by a developer to test the overall 
// functionality, or some specific aspect of a transfer tool, then a synthetic data 
// source can be specified to create the need files or tree.
//
// The logic contained in this file processes synthetic data sources. A synthetic
// data can be specified as follows:
// 	<synthetic data prefix>[._-]<tree specification>
//
// Examples of supported "synthetic data prefixes" are:
// 	/dev/synthetic
//	/dev/syndata
//
// Tree Specifications have the following syntax:
// 	[L<max levels>][D<max directory/level][F<max files/directory][+<level to start writing files>]
// where
// 	L - maximum levels in the tree. Note that if L0 is specified, then a
// 	    file is written, since a tree with 0 levels is not a tree
//	D - maximum number of directories per level. Note that if L1 is specified,
//	    then no directories are written, since no directories will go in "leaf
//	    levels"
//	F - maximum number of files per directory
//	+ - the level at which to start writing files. By default, files are only
//	    written at the "leaf level", which is <max levels> - 1.
//
// Tree Specification elements are case-sensitive. Lowercase letters will cause the 
// specification to be invalid. Not all, or any elements need to be specified in a tree 
// specification. If a  certain element is not specified, then a default value is used. 
// For example, given the following synthetic data source:
// 	/dev/syndata.F5
// the tree specification would be equivalent to:
// 	L1D0F5+0
//
// Likewise the synthetic data source:
// 	/dev/synthetic-L3+0
// would have a tree specification equivalent to:
//	L3D1F1+0
//
// To be more explicit, if an element in a tree specification is not specified, the
// default for that element is as follows:
// 	L - 0 if the data source is a synthetic data prefix only (i.e. /dev/syndata)
// 	    1 if the data source indicates a directory (or tree) (i.e. /dev/syndata/)
//	D - 0 if max level (L) <= 1
//	    1 if max level (L) > 1
//	F - 1
//	+ - max level (L) - 1
//
// Note that tree specifications that specify max directories (D) without specifying
// max levels (L) will never have sub directories in the tree, because the default
// value for max levels is 1, which makes that level a "leaf level". So the 
// equivalent tree specification for the following synthetic data source:
// 	/dev/syndata_D5F10
// is
// 	L1D0F10+0
//
// Finally, as implied above, a single synthetic data "file" is generated by the 
// following synthetic data sources:
// 	/dev/syndata
// 	/dev/syndata.L0
//	/dev/synthetic
//	/dev/synthetic.L0
//
// That is to say, any synthetic data source that explicitly has max levels (L) set
// to 0, will only generate 1 file, no matter what number is specified for files per
// directories.
// --------------------------------------------------------------------------------

#ifndef  __PATH_SYNDATA_H
#define  __PATH_SYNDATA_H

class SyntheticDataSource : public Path {
protected:

   friend class Pool<SyntheticDataSource>;

   struct options*   _o;			// options structure - TBD: should probably only pass necessary options for synthetic data, notthe whole structure
   int               _rank;			// seed for random data - TBD: rework, or remove altogether
   SyndataBufPtr     _synbuf;			// buffer of synthetic data to be read from
   SyndataTreeSpec*   _spec;			// synthetic directoy specification (used by directory operations)
   int		     _dlvl;			// current synthetic directory level (used by directory operations)
   int		     _dnum;			// current synthetic directory number (used by directory operations)
   int		     _fnum;			// current synthetic file number (used by directory operations)
   

   virtual bool do_stat_internal() {
			// syndataSetAttr() returns non-zero on failure
      return(!syndataSetAttr(_item->path,&(_item->st),&_dlvl,_o->syn_size));
   }

   SyntheticDataSource()
      : Path(),
        _o(NULL),
        _rank(-1),
        _synbuf(NULL),
	_spec(NULL),
	_dlvl(-1),							// if _dlvl < 0 -> not in a directory
	_dnum(0),
	_fnum(0) {

      strncpy(_item->path, "SyntheticDataSource", PATHSIZE_PLUS);
   }

   // we expect args from the Factory:
   //
   // (0) struct options *  [options]
   // (1) int               [rank]
   //
   virtual void factory_install_list(int count, va_list list) {
      _o    = va_arg(list, struct options *);
      _rank = va_arg(list, int);
      _dlvl = va_arg(list, int);
   }

   virtual bool initialize_buffer() {
      if (!syndataExists(_synbuf))
         _synbuf = syndataCreateBufferWithSize(((_o->syn_pattern[0]) ? _o->syn_pattern : NULL),
                                               ((_o->syn_pattern[0])  ? SYN_PATTERN_SIZE : -_rank));
      return(_synbuf != NULL);
   }

public:

   virtual ~SyntheticDataSource() {
      close_all();              // see Path::operator=()
   }

   virtual bool    supports_n_to_1() const  { return false; }


   virtual bool    lchown(uid_t owner, gid_t group)      { NO_IMPL(lchown); }
   virtual bool    chmod(mode_t mode)                    { NO_IMPL(chmod); }
   virtual bool    utime(const struct utimbuf* ut)       { NO_IMPL(utime); }
   virtual bool    utimensat(const struct timespec times[2], int flags) { NO_IMPL(utimensat); }

   virtual bool    access(int mode)               { return(1); }	// Always successful
   virtual bool    faccessat(int mode, int flags) { access(mode); }	

   virtual bool open(int flags, mode_t mode) {
      if (flags == O_RDONLY) {
         if (!initialize_buffer()) {
	    _errno = EFAULT;				// errors encountered when allocating/initializing _synbuf
            errsend_fmt(FATAL, "Rank %d: Synthetic-data buffer is not allocated and does not exist!\n", _rank);
            unset(IS_OPEN);
         }
         else
            set(IS_OPEN);
      }
      else
         _errno = EACCES;				// invalid flags specified

      return is_open();
   }

   virtual bool close() {
      unset(IS_OPEN);
      _synbuf = syndataDestroyBuffer(_synbuf);		// clean up the data buffer ...
      return true;
   }

    virtual char *realpath(char *resolved_path) {
       if(NULL == resolved_path) {
           resolved_path = (char *) malloc(strlen(_item->path)+1);
           if(NULL == resolved_path) {
               _errno = errno;
               return NULL;
           }
       }

       strcpy(resolved_path, _item->path);
       return resolved_path;
   }

   // read/write to/from caller's buffer
   virtual ssize_t read(char* buf, size_t count, off_t offset) {
      int rc = syndataFill(_synbuf, buf, count);

      if (rc) {
         errsend_fmt(NONFATAL, "Failed to copy from synthetic data buffer. err = %d", rc);
	 errno = _errno = EIO;				// could not fill buffer
         return -1;
      }
      _item->st.st_atim.tv_sec = time((time_t *)NULL);	// set access time
      _item->st.st_atim.tv_nsec = 0;
      return count;
   }

   // we are only a source, not a sink
   virtual ssize_t write(char* buf, size_t count, off_t offset) { NO_IMPL(write); }

   virtual bool opendir() {
      if (!(_spec = syndataGetTreeSpec(_item->path))) {
         unset(IS_OPEN_DIR);
	 _errno = ENOENT;				// invalid directory specification
      }
      else if (!_spec->max_level) {
	 unset(IS_OPEN_DIR);
	 _errno = ENOTDIR;				// directory specification implies no directory
      }
      else {
	if (_dlvl < 0)					// initialize current level - if needed
	   _dlvl = syndataGetDirLevel(_item->path);
        _dnum = _fnum = 0; 				// initialize directory and file counters
	set(IS_OPEN_DIR);
      }

      return is_open();
   }

   virtual bool closedir() {
      unset(IS_OPEN_DIR);
      if(_spec) free(_spec);				// deallocate directory specification upon closing - if ncessary
      return true;
   }

   virtual bool readdir(char* path, size_t size) {
      int nxtlvl = _dlvl+1;
      char nbuf[PATHSIZE_PLUS];				// a buffer to construct a directory entry

      if (_dlvl > _spec->max_level) {			// if current level is > max level, something is very wrong!
	  _errno = EBADF;				
	  return(false);				// we are done reading this directory
      }
							// if next level < max level -> not at leaf directory. Generate 
							// directories if needed
      if (nxtlvl < _spec->max_level && _dnum < _spec->max_dirs)
	  sprintf(nbuf,SYN_DIR_FMT,nxtlvl,_dnum++);	// generate directory name and increment directory number
							// if current level >= the level to start files, then do so
      else if (_dlvl >= _spec->start_files && _fnum < _spec->max_files)
	  sprintf(nbuf,SYN_FILE_FMT,_fnum++,_o->syn_suffix);	// generate file name and increment file number
      else
	  nbuf[0] = '\0';				// Nothing to generate? set to the empty string

      if (strlen(nbuf) > size) {
	 _errno = EINVAL;				// Cannot fit entry into buffer provided
	 return(false);
      }
      strncpy(path,nbuf,size);				// copy the buffer to te path entry ...
      return(true);
   }

   virtual bool    mkdir(mode_t mode)    { NO_IMPL(mkdir); }

   virtual bool    remove()              { return close(); }
   virtual bool    unlink()              { return remove(); }
};

#endif // __PATH_SYNDATA_H


